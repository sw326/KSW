

# < 복습 >

## OOP 특성
1) 상속: 부모의 '모든 것'을 '상속'(== '사용할 수 있는 것')
	- 코드의 중복( reuse )
	- 자식 객체 생성되려면, 먼저 부모가 생성돼야 함
	  ( 기본 생성자: 다른 생성자가 없을 경우에만 JVM이 만들어줌 )
	- 생성자 첫 라인 super(); 생략
	- 클래스 간의 상속 ' 단일 상속 '
	- 모든 객체는 Object의 자손 ( 묵시적 상속 )
	- 부모 메소드를 자식에서 재정의
	- 형변환
		- 자동(수평적) 자 -> 부 by JVM => 넓은 범주가 필요할 때
		- 강제(수직적) 부 -> 자 by 개발자 => 많은 기능이 필요할 때
	- 형제관계는 '남남'관계 : 형변환 불가!
	- 강제 형변환은 '원래 자기 타입'을 되찾을 때 ( 자식의 원래 기능을 사용할 수 있음 )
	  
	  
1) 다형: 같은 타입 객체의 같은 메소드가 '다른 일'을 하는 것( Overriding )
2) 은닉: 외부 프로그램 '속성값(맴버변수 값)'을 감추는 것
3) 캡슐화: 객체의 캡슐화, 메소드의 캡슐화




# 예외 처리

1) 예외 ( Exception ) 
    '돌발상황' : 프로그램이 정상적으로 진행되지 못하게 하는 다양한 상황
    
2) 처리 목적
   프로그램 진행시에 발생할 수 있는 '돌발상황'을 예외로 미리 정해놓고,
   해당하는 예외가 발생할 경우 '적절한 조치'를 취해서, 프로그램이 '정상작동'
   되도록 하는 것
   
3) 계층도 
				   Object
					 |
					Throwable
					|                |
				Error                 Exception
						    |                         |
						CompileException      RuntimeException
						
		ex) IOException (CompileException)
			NumberFormatException (RuntimeException)
4) 특징
	1) throw 로 예외 객체를 던짐( 발생시킴 )
	2) throws 로 예외 발생 가능 '표식'을 함 (== 소극적으로 '떠넘김')
	3) try catch로 잡을 수 있음 
	   
	   ex) day09/B.java
5) 방법
	1) 때려 잡는 법
		try{
			예외가 발생할 수 있는 구문 ( 생성자 || 메소드 호출)
		}catch(예외타입 예외객체){
			예외처리 로직
		}
	1) 떠넘기는 법
	   throws 예외타입
	   
6) 순서 ( try 블록 언에 2개 이상의 예외가 발생할 수 있는 경우 )
	1) 상속관계 X
		순서 X - 아무 예외나 먼저 잡아줌
		 
	2) 상속관계 O
	   순서 O - 하위 예외부터 먼저 잡아줌
	   	   
	   ex) day09/B.java
	   
	   Why? 왜 하위예외를 만들어서 먼저 잡아주는 것이 좋은가요?
	   '구체적이고 세련된 처리를 위해서'
	   
7) 2개 이상의 예외를 떠넘길 때
   cf) '떠넘김'과 '때려잡음' 처리를 섞어 사용해도 됨

8) finally {} // 블럭, 바디, 절
	1)  항상 수행되는 절
		- 예외 발생 여부와 상관없이 수행
		- 심지어 ... return을 만나더라도 finally절 수행 후 리턴
	2) try 절이 나오면 catch || fianally 혹은 catch && finally 여야 한다.
	3) return < finally < System.exit(-1)
	   - System.exit(0) // 정상 종료
	   - System.exit(-1) // 비정상 종료
		
		ex) day09/C.java